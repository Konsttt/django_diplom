## Диплом python backend. Интернет-магазин на Django REST framework.
### netology.ru
### Запуск:
- Требования: чтобы работал celery - проект развёртывать на Ubuntu/Linux или wsl c Ubuntu/Linux
1. Создать БД Postgresql
2. Клонировать проект на свой компьютер/сервер:
```shell
git clone https://github.com/Konsttt/django_diplom.git
```
3. Создать виртуальное окружение и установить пакеты из requirements.txt:
```shell
python3 -m venv venv
source ./venv/bin/activate
pip install -r requirements.txt
```
4. В подготовленном файле 'how_fill_env.txt', согласно пояснениям, ввести свои данные и переименовать в '.env'
(Для отправки почты клиентам, лучше настроить свой почтовый сервер. 
Например, почта yandex, rambler блокировалась в рамках защиты от спама, не отправлялась. 
Пришлось на vps reg.ru развернуть свой почтовый сервер mailcow. В сети много туториалов, не долго.)
5. В папке backend создать пакет migrations с файлом __init__.py (т.к. migrations, venv и т.д. в .gitignore)
6. Применить миграции:
```shell
python manage.py makemigrations
python manage.py migrate
```
7. Создать супер-юзера. 
(Админ пригодится для безопасного перевода обычного пользователя в ранг менеджера магазина)
```shell
python manage.py createsuperuser
```
8. Далее три команды для запуска проекта. Каждая команда в своём терминале:
```shell
source ./venv/bin/activate
python manage.py runserver 0.0.0.0:8000
```
```shell
redis-server
```
```shell
source ./venv/bin/activate
python -m celery -A django_diplom worker -l info
```
9. Далее соглассно url делаем запросы: реализован ряд темплейтов, часть веба на интерфейсе drf-django, часть 
на темплейтах. Создаём пользователя, на почту пользователя отправляется письмо со ссылкой, 
пользователь ещё не активирован, после перехода по ссылке пользователь активируется - 
теперь можно логиниться смотреть продукты, создавать контакты, корзину, заказ и т.д.
Чтобы загрузить продукты из yaml-файла, создаём юзера, потом в админке или в БД с помощью DBeaver, например,
переводим его в менеджеры поменяв поле buyer на shop. Менеджером загружаем продукты, просматриваем заказы пользователей. 
10. В четвёртом окне терминала можно запустить тесты:
```shell
source ./venv/bin/activate
pytest --cov=backend
```
11. Документация API: http://<yourserver>:8000/api/v1/docs/
12. Анализ/оптимизация запросов: http://<yourserver>:8000/silk/
    (если сервер не удалённый, то <yourserver> это localhost)

### Что реализовано:
- регистрация, подтверждение регистрации по email, авторизация пользователей;
- пользователь может добавлять в корзину товары от разных магазинов;
- пользователь может подтверждать заказ с вводом адреса доставки;
- пользователь получает email с подтверждением заказа;
- пользователь может переходить на страницу "Заказы" и открывать созданный заказ;
- менеджеры могут загружать yaml-файлы с товарами на сайт(в папку медиа), в БД хранятся ссылки на файлы;
- файлы можно загружать не только через форму, но и через админ-панель;
- менеджеры видят товары, которые заказали из их магазина;
- пользователи видят и редактируют только свои контакты
- менеджеры видят все контакты, редактируют только свои (у админа все права)
- долгие процессы - отправка писем: для подтверждения аккаунта, для сброса пароля, 
для отправки заказа - переведены в tasks и обрабатываются с помощью celery и redis
- где возможно во views.py используются ViewSets, часть классов на ApiView
- тестами покрыто более 50% кода, используется pytest, model_bakery
- реализована документация с помощью пакета DRF-Spectacular. Очень удобная вещь, с возможностью тестирования, 
отправки запросов прямо из веб-формы: http://<your_project_host>:8000/api/v1/docs/
Описание api - реализовано в свёрнутых блоках перед классами во views.py (в Pycharm удобно) 
- настроен DRF-тротлинг. Так же добавлена в тесты функция, которая проверяет, 
что анониму позволено не более 10 запросов в минуту
- добавлена авторизация через соцсети: из VK и с YandexID в рамках пакета Python Social Auth - Django
- добавлен и настроен удобный анализатор запросов - пакет Silk https://github.com/jazzband/django-silk
  (Проанализировал запросы. Проблем именно с БД явных нет, удобно видно время, и количество очередей. 
Общее вермя запросов, довольно большое - максимум до 1,5сек - но это связано с тем, что проект на WSL Ubuntu и 
немного подтормаживает, т.е. грубо говоря проблема сервера. А так сами запросы именно к БД по 10-50мс 
и максимум 5 queries, postgres тоже на wsl.)


### Какие были "подводные камни"/сложности:
- почта от популярных почтовых серверов не заработала. 
Пришлось развернуть свой почтовый сервер Mailcow. Работает отлично.
- в браузере боролся с сохранением сессии/токена. Т.е. после того как пользователь авторизуется в браузере 
и далее делает запрос например на создание своего контакта, то он воспринимался как аноним. Исправил, 
почитав документацию, - одна функция 
user = authenticate(request, username=request.data['email'], password=request.data['password']) не авторизует. 
Нужно ещё вот это обязательно login(request, user) !
- чтобы заработал celery - пришлось уходить с Windows, вернее развернул WSL Ubuntu на Windows и перенёс туда проект.
  (Давно бы перешёл на Ubuntu, но ничто не сравнится со скоростью работы удалённого рабочего стола rdp Windows, 
удалённый рабочий стол на Ubuntu заметно лагает). С wsl удобно ещё то, что проект теперь не на localhost, а имеет свой
ip адрес, беда в том, что этот ip после перезагрузки всегда разный, поэтому вынес его в .env файл, главное не забыть менять.
- c celery самым трудным было пожалуй - переопределение метода post родительского класса ResetPasswordRequestToken в 
моём классе ResetPassword - чтобы вместо signal родительского класса, отправлять письмо с помощью task celery.
- в сети на первый взгляд много туториалов по авторизации из соцсетей, но все они не доведены до конца, пришлось разбираться. 
Особенно с YandexID, т.к. в документации пакета описание работы с VK есть, а вот с Яндекс нет. 
Сначала делал для яндекса свои темплейты и функции по документации из яндекса и уже получал данные пользователя 
и токен в обмен на код, но что с ними делать, как создавать пароль, как авторизовывать без пароля не понятно, 
в общем велосипед разрастался. И затем обнаружил, что файл яндекса 'social_core.backends.yandex.YandexOAuth2' 
есть в проекте, просто описания на него нет. Ну здесь уже всё быстро завелось с YandexID по аналогии с VK.
